Require Import Setoid ProofIrrelevance FunctionalExtensionality ClassicalDescription.
Require Export SetCategory DiscreteCategory EquivalenceSet EquivalenceClass Grothendieck EquivalenceRelationGenerator.
Require Import Common Limits Functor NaturalTransformation FunctorCategory.

Set Implicit Arguments.

Local Infix "*" := ProductCategory.
Local Notation "C ^ D" := (FunctorCategory D C).

Section InitialTerminal.
  Local Transparent Object Morphism.

  Hint Extern 1 (_ = _) => apply (@functional_extensionality_dep _); intro.

  Local Ltac t := repeat (hnf in *; simpl in *; intros; try destruct_exists; try destruct_to_empty_set); auto.

  Definition TypeCatEmptyInitial : @InitialObject _ _ TypeCat Empty_set. t. Defined.
  Definition TypeCatSingletonTerminal : @TerminalObject _ _ TypeCat unit. t. Defined.
  Definition SetCatEmptyInitial : @InitialObject _ _ SetCat Empty_set. t. Defined.
  Definition SetCatSingletonTerminal : @TerminalObject _ _ SetCat unit. t. Defined.
End InitialTerminal.

Section SetColimits.
  (* An element of the colimit is an pair [c : C] and [x : F c] with
     (c, x) ~ (c', x') an equivalence relation generated by the
     existance of a morphism [m : c -> c'] with m c x = m c x'. *)
  Local Transparent Object Morphism.

  Variable objC : Set.
  Variable morC : objC -> objC -> Set.
  Variable C : SmallSpecializedCategory morC.
  Variable F : SpecializedFunctor C SetCat.
  Let F' := (F : SpecializedFunctorToSet _) : SpecializedFunctorToType _.
  Set Printing Universes.

  Definition SetColimit_Object_pre := SetGrothendieckPair F. (* { c : objC & F.(ObjectOf') c }.*)
  Global Arguments SetColimit_Object_pre /.
  Definition SetColimit_Object_equiv_sig :=
    generateEquivalence (fun x y : SetColimit_Object_pre => inhabited (Morphism (CategoryOfElements F') x y)).
  Definition SetColimit_Object_equiv :=
    proj1_sig SetColimit_Object_equiv_sig.
  Definition SetColimit_Object_equiv_Equivalence :=
    proj2_sig SetColimit_Object_equiv_sig.

  Local Infix "~=" := SetColimit_Object_equiv (at level 70, no associativity).

  Lemma SetColimit_Property_Morphism_respectful (S : SetCat) (m : Morphism (SetCat ^ C) F (DiagonalFunctor SetCat C S)) c x c' x'
    (a := Build_SetGrothendieckPair F c x) (b := Build_SetGrothendieckPair F c' x') :
    a ~= b
(*    inhabited (Morphism (CategoryOfElements ((F : SpecializedFunctorToSet _) : SpecializedFunctorToType _)) a b)*)
    -> m c x = m c' x'.
    change c with (SetGrothendieckC a).
    change x with (SetGrothendieckX a).
    change c' with (SetGrothendieckC b).
    change x' with (SetGrothendieckX b).
    clearbody a b; clear c x c' x'.
    intro H; induction H; try solve [ etransitivity; eauto ].
    destruct H as [ [ p H ] ].
    pose (fg_equal (m.(Commutes') _ _ p)) as e; simpl in *.
    unfold SetGrothendieckC, SetGrothendieckX.
    t_rev_with t'.
  Qed.

  Section chooser.
    Variable chooser : SetColimit_Object_pre -> SetColimit_Object_pre.
    Hypothesis chooser_respectful : forall x y, x ~= y -> chooser x = chooser y.
    Hypothesis chooser_injective : forall x, { y | x ~= y /\ chooser y = y }.

    Local Ltac t_fin := simpl in *;
      reflexivity || eassumption || (constructor; assumption) || (symmetry; constructor; assumption) ||
        solve [ etransitivity; eauto ] ||
          solve [ symmetry; etransitivity; eauto ].

    Definition SetColimitByChooser_Object : TerminalCategory * SetCat := (tt, { x | chooser x = x } ).

    Let chooser' (x : SetColimit_Object_pre) : { x | chooser x = x }.
      exists (proj1_sig (chooser_injective x)).
      abstract (intro_proj2_sig_from_goal; intuition).
    Defined.

    (* TODO: Automate better. *)
    Definition SetColimitByChooser_Morphism : Morphism (FunctorCategory C SetCat)
      ((SliceCategory_Functor
        (FunctorCategory C SetCat) F) (fst SetColimitByChooser_Object))
      ((DiagonalFunctor SetCat C) (snd SetColimitByChooser_Object)).
      hnf; simpl.
      match goal with
        | [ |- SpecializedNaturalTransformation ?F ?G ] =>
          refine (Build_SpecializedNaturalTransformation F G
            (fun c : objC =>
              (fun S : F c =>
                chooser' (Build_SetGrothendieckPair F c S)
              )
            )
            _
          )
      end.
      abstract (
        simpl; intros; hnf;
          repeat (apply functional_extensionality_dep; intro);
            simpl_eq;
            match goal with
              | [ |- proj1_sig ?x = proj1_sig ?y ] =>
                simpl_do do_rewrite_rev (proj2 (proj2_sig x)); simpl_do do_rewrite_rev (proj2 (proj2_sig y));
                  apply chooser_respectful;
                    simpl_do do_rewrite_rev (proj1 (proj2_sig x)); simpl_do do_rewrite_rev (proj1 (proj2_sig y))
            end;
            match goal with
              | [ m : _ |- _ ]
                => apply gen_sym;
                  apply gen_underlying;
                    constructor; hnf; simpl;
                      exists m; reflexivity
              | [ m : _ |- _ ]
                => apply gen_underlying;
                  constructor; hnf; simpl;
                    exists m; reflexivity
            end
      ).
    Defined.

    Definition SetColimitByChooser_Property_Morphism_mor (S : SetCat)
      (m : Morphism (SetCat ^ C) F (DiagonalFunctor SetCat C S)) :
      snd (SetColimitByChooser_Object) -> S
      := fun x => m (SetGrothendieckC (proj1_sig x)) (SetGrothendieckX (proj1_sig x)).

    Global Arguments SetColimitByChooser_Property_Morphism_mor [S] m _ /.

    Definition SetColimitByChooser_Property_Morphism (o' : @CosliceCategory _ (SetCat ^ C) F (DiagonalFunctor SetCat C)) :
      Morphism
      (@CosliceCategory _ (SetCat ^ C) F (DiagonalFunctor SetCat C))
      (existT _ SetColimitByChooser_Object SetColimitByChooser_Morphism) o'.
      exists (tt, fun d => (@SetColimitByChooser_Property_Morphism_mor (snd (projT1 o')) (projT2 o') d)).
      abstract (
        simpl in *;
          nt_eq;
          apply SetColimit_Property_Morphism_respectful;
            simpl;
              match goal with
                | [ |- context[proj1_sig ?x] ] => induction (proj1 (proj2_sig x))
              end;
              unfold SetColimit_Object_pre in *;
                repeat match goal with
                         | [ H : SetGrothendieckPair _ |- _ ] => destruct H
                       end;
                t_fin
      ).
    Defined.

    (* TODO: Automate this better *)
    Definition SetColimitByChooser : Colimit F.
      exists (existT _ SetColimitByChooser_Object SetColimitByChooser_Morphism).
      intro o'.
      exists (SetColimitByChooser_Property_Morphism o').
      abstract (
        hnf; intros; simpl in *;
          destruct_sig;
          simpl_eq; try solve [ unfold Morphism; trivial ];
            apply functional_extensionality_dep; intro;
              simpl in *;
                destruct_sig;
                match goal with
                  | [ x : SetGrothendieckPair _, H : _ |- _ ] => apply (f_equal (@ComponentsOf _ _ _ _ _ _ _ _)) in H;
                    fg_equal;
                    let c := fresh in destruct x as [ c x ];
                      specialize (H c); fg_equal; specialize (H x);
                        simpl;
                          rewrite <- H;
                            clear H
                end;
                f_equal;
                simpl_eq;
                intro_proj2_sig_from_goal; split_and; simpl in *;
                  match goal with
                    | [ H0 : _ = ?x, H1 : _ = ?y |- ?x = ?y ] => rewrite <- H0 at 1; rewrite <- H1
                  end;
                  apply chooser_respectful;
                    assumption
      ).
    Defined.
  End chooser.

  Section axiom.
    Hypothesis inhabited_dec : forall x y : SetColimit_Object_pre, {x ~= y} + {~(x ~= y)}.

    Definition SetColimit_Object : TerminalCategory * SetCat := (tt, EquivalenceSet SetColimit_Object_equiv).

    (* TODO: Automate better. *)
    Definition SetColimit_Morphism : Morphism (FunctorCategory C SetCat)
      ((SliceCategory_Functor
        (FunctorCategory C SetCat) F) (fst SetColimit_Object))
      ((DiagonalFunctor SetCat C) (snd SetColimit_Object)).
      hnf; simpl.
      match goal with
        | [ |- SpecializedNaturalTransformation ?F ?G ] =>
          refine (Build_SpecializedNaturalTransformation F G
            (fun c : objC =>
              (fun S : F c =>
                setOf SetColimit_Object_equiv_Equivalence inhabited_dec
                (Build_SetGrothendieckPair F c S)
              )
            )
            _
          )
      end.
      abstract (
        simpl; intros; hnf;
          repeat (apply functional_extensionality_dep; intro);
            simpl;
              apply EquivalenceSet_forall__eq;
                intros; repeat (split; intros);
                  clear_InSet;
                  t_with t';
                  match goal with
                    | [ m : _ |- _ ]
                      => apply gen_sym;
                        apply gen_underlying;
                          constructor; hnf; simpl;
                            exists m; reflexivity
                    | [ m : _ |- _ ]
                      => apply gen_underlying;
                        constructor; hnf; simpl;
                          exists m; reflexivity
                  end
      ).
    Defined.

    Definition SetColimit_Property_Morphism_mor_pre (S : SetCat) (m : Morphism (SetCat ^ C) F (DiagonalFunctor SetCat C S)) :
      forall (D : snd (SetColimit_Object)), exists! s : S, forall d, InSet D d -> m (SetGrothendieckC d) (SetGrothendieckX d) = s.
      unfold SetColimit_Object; simpl; intro D; destruct (SetInhabited D) as [ cx H ].
      exists (m (SetGrothendieckC cx) (SetGrothendieckX cx)).
      abstract (
        split; unfold SetColimit_Object_pre in *; intros; auto; clear_InSet;
          match goal with
            | [ H : SetEquivalent _ _ _ |- _ ] => induction H; auto;
              try solve [ etransitivity; eauto ]
          end;
          match goal with
            | [ H : inhabited _ |- _ ] => destruct H as [ [ f H ] ]
          end;
          pose m.(Commutes');
            simpl in *;
              fg_equal;
              unfold SetGrothendieckC, SetGrothendieckX in *;
                t_rev_with t' (* [t_with t'] gives "Anomaly: Uncaught exception Failure("hd"). Please report.", if
                                 I add a second argument to the definition, [(eq_dec : forall s0 s1 : S, {s0 = s1} + {s0 <> s1})] *)
      ).
    Defined.

    Definition SetColimit_Property_Morphism_mor_sig (S : SetCat) (m : Morphism (SetCat ^ C) F (DiagonalFunctor SetCat C S)) :
      forall (D : snd (SetColimit_Object)), { s : S | forall d, InSet D d -> m (SetGrothendieckC d) (SetGrothendieckX d) = s }.
      intros; apply constructive_definite_description.
      apply SetColimit_Property_Morphism_mor_pre.
    Defined.

    Definition SetColimit_Property_Morphism (o' : @CosliceCategory _ (SetCat ^ C) F (DiagonalFunctor SetCat C)) :
      Morphism
      (@CosliceCategory _ (SetCat ^ C) F (DiagonalFunctor SetCat C))
      (existT _ SetColimit_Object SetColimit_Morphism) o'.
      exists (tt, fun d => proj1_sig (@SetColimit_Property_Morphism_mor_sig (snd (projT1 o')) (projT2 o') d)).
      abstract (
        simpl in *;
          nt_eq;
          match goal with
            | [ |- proj1_sig ?x = _ ] => let H := fresh in
              pose (proj2_sig x _ (setOf_refl _ _ _)) as H;
                simpl in *;
                  exact H || symmetry; exact H
          end
      ).
    Defined.

    Definition SetColimit : Colimit F.
      exists (existT _ SetColimit_Object SetColimit_Morphism).
      intro o'.
      exists (SetColimit_Property_Morphism o').
        hnf; intros; simpl in *;
          destruct_sig;
          simpl_eq; try solve [ unfold Morphism; trivial ];
            apply functional_extensionality_dep; intro;
              simpl in *;
                destruct_sig.
        match goal with
          | [ x : _ |- _ ] => destruct (SetInhabited x)
        end.
                match goal with
                  | [ x : SetGrothendieckPair _, H : _ |- _ ] => apply (f_equal (@ComponentsOf _ _ _ _ _ _ _ _)) in H;
                    fg_equal;
                    let c := fresh in destruct x as [ c x ];
                      specialize (H c); fg_equal; specialize (H x);
                        simpl
                end.
                match goal with
                  | [ H : InSet ?S ?x |- _ ] => let H' := fresh in
                    assert (H' : S = setOf SetColimit_Object_equiv_Equivalence inhabited_dec x);
                      [
                        apply sameSet_eq;
                          intro; split; intros;
                            clear_InSet;
                            t_rev_with t';
                            try reflexivity
                      | ]; rewrite H' at 1 (* gives "Anomaly: Evar ?1948 was not declared. Please report." *)
(*                      simpl in *;
                        rewrite H' in *; clear H' *)
                end.

                intro_proj2_sig_from_goal; split_and; simpl in *.
                match goal with
                  | [ H : forall _ _, _, H' : _ |- _ ] => specialize (H _ H')
                end.
                match goal with
                  | [ H : SetGrothendieckPair _ |- _ ] => destruct H; simpl in *
                end.
                t_with t'.
End Limits.

Section DiscreteLimits.
  Variable O : Set.
  Variable eq_dec : forall a b : O, {a = b} + {a <> b}.
  Let D := DiscreteSmallCategory O eq_dec.

  Variable F : Functor D SetCat.

  Lemma eq_dec_refl' x : forall H, eq_dec x x <> right H.
    intro H; contradict H; reflexivity.
  Qed.

  Lemma eq_dec_refl_helper a b : (forall H, eq_dec a b <> right H) -> (exists H, eq_dec a b = left H).
    intro H.
    destruct (eq_dec a b) as [ e |  ].
    exists e; trivial.
    specialized_assumption ltac:(try tauto).
  Qed.

  Lemma eq_dec_refl x : exists H, eq_dec x x = left H.
    apply eq_dec_refl_helper; intro; firstorder.
  Qed.

  Lemma eq_dec_refl_use x A (a b : A) : (if eq_dec x x then a else b) = a.
    pose (eq_dec_refl x) as H.
    destruct H as [ ? H ].
    rewrite H.
    reflexivity.
  Qed.

(*  Lemma eq_dec_refl' x : forall H, ~eq_dec x x = right H.
    intro H; contradict H; reflexivity.
  Qed.
*)
  Definition DiscreteSetColimit : Colimit F.
    hnf; simpl.
    Print sigT.
    match goal with
      | [ |- { _ : { αβ : _ & SmallNaturalTransformation (@?F0 αβ) (@?G0 αβ) } & _ } ] =>
        let αβ := constr:((tt, { o : O & F o })) in
          refine (existT _
            (existT
              _
              αβ
              (Build_SmallNaturalTransformation _ _ (fun c : D => (fun Fc : F c => existT _ c Fc) : Morphism SetCat (F0 αβ c) (G0 αβ c)) _)
            )
            _
          )
    end.
    hnf; simpl in *; intro o'.
    destruct o' as [ [ [ ] S ] f ]; simpl in *.
    match goal with
      | [ |- @sig (@sig ?A ?P) ?P' ] =>
        let gh := constr:((tt, (fun oFo => f (projT1 oFo) (projT2 oFo)))) in
          cut (P gh);
            try (
              let x := fresh in intro x;
                let m := constr:(exist P gh x) in
                  exists m
            )
    end.
    hnf; simpl in *.
    intro x'.
    simultaneous_rewrite RightIdentitySmallNaturalTransformation; simpl in *.
    destruct x' as [ [ [ ] f' ] H' ].
    simpl in *.
    Lemma sig_equal A P (s s' : @sig A P) : proj1_sig s = proj1_sig s' -> s = s'.
      intros; destruct s, s'; simpl in *; subst; f_equal; apply proof_irrelevance.
    Qed.
    apply sig_equal; simpl in *.
    f_equal.
    repeat (apply functional_extensionality_dep; intro).
    destruct x; simpl in *.
    match goal with
      | [ H : _, H' : _ |- _ ] => rewrite <- H; rewrite <- H'; simpl; f_equal
    end.
    snt_eq.
    Grab Existential Variables.
    simpl in *; intros.
    subst D.
    repeat (apply functional_extensionality_dep; intro).
    match goal with
      | [ |- existT ?a ?b ?c = existT ?a ?b' ?c' ] => cut (b = b');
        try (let H := fresh in intro H; simultaneous_rewrite H || simultaneous_rewrite_rev H);
          f_equal
    end.
    generalize x.
    clear H0.
    generalize dependent x.
    generalize F; clear F.
    generalize m; clear m.
    unfold DiscreteSmallCategory.
    unfold Morphism.
    simpl.
    Eval simpl in Morphism
    {|
    SObject := O;
    SMorphism := fun s d : O => if eq_dec s d then unit else Empty_set;
    SIdentity := DiscreteCategory_Identity O eq_dec;
    SCompose := DiscreteCategory_Compose O eq_dec;
    SAssociativity := DiscreteSmallCategory_subproof O eq_dec;
    SLeftIdentity := DiscreteSmallCategory_subproof0 O eq_dec;
    SRightIdentity := DiscreteSmallCategory_subproof1 O eq_dec |} s s.
    unfold smallcat2cat in *.
    simpl in *.
    destruct F.
    simpl in *.
    clear F.
    generalize dependent eq_dec.
    clear eq_dec.
    intro.
    pattern (eq_dec s s).
    generalize
    destruct (eq_dec s s).
    destruct m.
    destruct F.
    simpl in *.
    simpl in *.
    match (eq_dec s s) with
      | left _ => assert H
      | right ?H => contradict H
    end.
    contradict (
    destruct (eq_dec s d); tauto || assumption || symmetry; assumption.
    match goal with
      | [ H : context[eq_dec ?a ?a] |- _ ] => generalize dependent H; destruct (eq_dec a a)
    end.
    rewrite <- H1.
    rewrite <- H'.
    simpl.
    f_equal.
    Require Import DefinitionSimplification.
    rewrite sigT_eta.
    match goal with
    match goal with
      | [ |- @sigT (@sigT ?A ?P) ?P' ] =>
        let αβ := constr:((tt, { o : O & F o })) in
          cut (P αβ);
            try (
              let x := fresh in intro x;
                let Aφ := constr:(existT P αβ x) in
                  exists Aφ(*
                  cut (P' Aφ);
                    try (
                      let y := fresh in intro y;
                        exact (existT P' Aφ y)
                    )*)
            )
    end.
    Focus 2.
    hnf; simpl in *.
    Print SmallNaturalTransformation.
    Set Printing All.
    Eval simpl in forall c : D, Morphism SetCat (F c) ((Build_Functor (smallcat2cat D) SetCat
        (fun _ : O =>
         @sigT O (fun o : O => @ObjectOf (smallcat2cat D) SetCat F o))
        (fun (s d : O)
           (_ : match eq_dec s d return Set with
                | left _ => unit
                | right _ => Empty_set
                end)
           (x : @sigT O (fun o : O => @ObjectOf (smallcat2cat D) SetCat F o)) =>
         x)
        (diagonal_functor_object_of_subproof SetCat D
           (@sigT O (fun o : O => @ObjectOf (smallcat2cat D) SetCat F o)))
        (diagonal_functor_object_of_subproof0 SetCat D
           (@sigT O (fun o : O => @ObjectOf (smallcat2cat D) SetCat F o)))) c).
    Unset Printing All.
    Eval simpl in forall c : O,
       @ObjectOf (smallcat2cat D) SetCat F c ->
       @sigT O (fun o : O => @ObjectOf (smallcat2cat D) SetCat F o).
    match goal with
      | [ |- SmallNaturalTransformation ?F ?G ] =>
        refine (Build_SmallNaturalTransformation _ _ (fun c : D => (fun Fc : F c => existT _ c Fc) : Morphism SetCat (F c) (G c)) _)
    end.
    intros; simpl; repeat (apply functional_extensionality_dep; intro).
    match goal with
      | [ |- existT ?a ?b ?c = existT ?a ?b' ?c' ] => cut (b = b');
        try (let H := fresh in intro H; simultaneous_rewrite H || simultaneous_rewrite_rev H);
          f_equal
    end.
    admit.
    subst D; simpl in *.
    destruct (eq_dec s d); tauto || symmetry; assumption.
    destruct D; simpl in *.
    hnf; simpl in *. intros o'.
    destruct o' as [ [ [ ] S ] f ]; simpl in *.
    match goal with
      | [ |- @sig (@sig ?A ?P) ?P' ] =>
        let gh := constr:((tt, (fun oFo => f (projT1 oFo) (projT2 oFo)))) in
          cut (P gh);
            try (
              let x := fresh in intro x;
                let m := constr:(exist P gh x) in
                  exists m
            )
    end.
    hnf; simpl in *.
    intro x'.
    simultaneous_rewrite RightIdentitySmallNaturalTransformation; simpl in *.
    destruct x' as [ [ [ ] f' ] H' ].
    simpl in *.
    match goal with
      | [ |- exist ?a ?b ?c = exist ?a ?b' ?c' ] => cut (b = b');
        try (let H := fresh in intro H; simultaneous_rewrite H || simultaneous_rewrite_rev H);
          f_equal
    end.
    Require Import ProofIrrelevance FunctionalExtensionality.
    admit.
    apply functional_extensionality_dep; intro.
    destruct x; simpl in *.
    rewrite <- H1.
    rewrite <- H'.
    simpl.
    f_equal.
    Require Import DefinitionSimplification.
    rewrite sigT_eta.
    match goal with
      | [ |- existT ?a ?b ?c = existT ?a ?b' ?c' ] => assert (b = b')
    end.

    admit.
    let H := fresh in intro H; simultaneous_rewrite_rev H.
    cut (x = (projT1 (H x o))).


    simpl.
    intro H5. simpl in H5. rewrite <- H5.

rewrite RightIdentitySmallNaturalTransformation in *; simpl in *.

    apply
    assert (H' = eq_refl _).
    intro H5.
    generalize dependent (tt, f').
    simultaneous_rewrite H5.

    intro x.
    let αβ := constr:((tt, { o : O & F o })) in
      let Aφ := constr:(existT _ αβ x) in
        idtac Aφ.
      (
      (tt, {o : O & F o})
H.
    exact (
    reflexivity.
        idtac A; idtac P; idtac P'
        let Aφ := fresh in evar (Aφ : @sigT A P);
          let
    end.
    refine (existT _ (existT _ (tt, { o : O & F o }) _) _).
    hnf; simpl; intro o'.
    destruct o' as [ [ [ ] S ] f ].
    simpl in *.
    refine (exist _ (exist _ (tt, fun oFo => f (projT1 oFo) (projT2 oFo)) _ ) _).
    hnf; simpl; intros x'.
    destruct x' as [ [ [ ] S' ] f' ].
    simpl.
    match goal with
      | [ |- exist ?a ?b ?c = exist ?a ?b' ?c' ] => cut (b = b');
        try (let H := fresh in intro H; simultaneous_rewrite H || simultaneous_rewrite_rev H);
          f_equal
    end.
    Require Import ProofIrrelevance FunctionalExtensionality.
    apply proof_irrelevance.
    rewrite RightIdentitySmallNaturalTransformation in *; simpl in *.
    apply functional_extensionality_dep; intro.
    subst.
    simpl.
    destruct x.
    simpl.
    f_equal.
    subst D.
    unfold DiscreteSmallCategory in *.
    simpl in *.
    unfold smallcat2cat in *.
    simpl in *.
    autorewrite with core.
    simpl in *.
    unfold ObjectOf, Object in *.
    unfold SComponentsOf in *.
    simpl in *.
    unfold smallcat2cat, ObjectOf in *; simpl in *.
    apply f_equal3.
    destruct x.
    simpl.
    intro H1. simultaneous_rewrite  H1.
    apply f_equal2


    unfold Limit.
    unfold
End DiscreteLimits.


(*Require Import Common FunctionalExtensionality.
Set Implicit Arguments.


Section EpiMono.
  Definition compose {A B C : Type} (f : B -> C) (g : A -> B) := (fun x => f (g x)).

  Variables S : Type.
  Hypothesis eq_dec : forall a b : S, {a = b} + {a <> b}.

  Lemma MonoInj B (f : B -> S) :
    (forall A (g g' : A -> B), (compose f g) = (compose f g') -> g = g')
    -> (forall x y : B, f x = f y -> x = y).
    intros H x y fxfy.
    unfold compose in *; simpl in *; fg_equal.
    apply (fun H' => H bool (fun b => if b then x else y) (fun _ => y) H' true).
    apply functional_extensionality_dep.
    intro b; destruct b; trivial.
  Qed.

  Lemma EpiSurj A (f : A -> S) :
    (forall C (g g' : S -> C), (compose g f) = (compose g' f) -> g = g')
    -> (forall x : S, exists y : A, f y = x).
    intro H.
    assert (H' := fun x H' => H bool (fun y => if eq_dec x y then true else false) (fun y => true) H').
    clear H.
    unfold compose in *; simpl in *; fg_equal.

    let H'T := type of H' in cut (~~H'T).
    clear H'; intro H.
    contradict H
    cut (~(~H')).
    contradict H'.
    intro x.
    pose (H bool (fun y => if eq_dec_B x y then true else false) (fun y => true)); simpl in *.
    fg_equal.
*)
